name: Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Manual trigger

env:
  AWS_REGION: eu-west-2
  TERRAFORM_VERSION: 1.6.0
  TFLINT_VERSION: v0.50.0

jobs:
  # Job 1: Build & Push Docker Image
  build-and-push:
    name: Build & Push to ECR
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      sha: ${{ github.sha }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_GITHUB_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get ECR repository URL
        id: ecr
        run: |
          # Get ECR repository URL using AWS CLI instead of Terraform
          ECR_URL=$(aws ecr describe-repositories --repository-names aimapp-repo --region ${{ env.AWS_REGION }} --query 'repositories[0].repositoryUri' --output text)
          echo "repository=$ECR_URL" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.ecr.outputs.repository }}
          tags: |
            type=sha,prefix=,format=long
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./aim
          file: ./aim/docker/Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=registry,ref=${{ steps.ecr.outputs.repository }}:buildcache
          cache-to: type=registry,ref=${{ steps.ecr.outputs.repository }}:buildcache,mode=max

  # Job 2: Terraform Deploy (runs after build)
  terraform-deploy:
    name: Terraform Deploy
    runs-on: ubuntu-latest
    needs: build-and-push
    permissions:
      id-token: write
      contents: read
    environment:
      name: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_GITHUB_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Setup TFLint
        uses: terraform-linters/setup-tflint@v4
        with:
          tflint_version: ${{ env.TFLINT_VERSION }}

      - name: Terraform Format Check
        id: fmt
        run: |
          cd infra
          terraform fmt -check
          echo "fmt_exit_code=$?" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Terraform Format
        if: steps.fmt.outputs.fmt_exit_code != 0
        run: |
          cd infra
          terraform fmt

      - name: Terraform Init
        run: |
          cd infra
          terraform init

      - name: Terraform Validate
        run: |
          cd infra
          terraform validate

      - name: TFLint
        run: |
          cd infra
          tflint --init
          tflint
        continue-on-error: true  # Don't fail pipeline on linting issues

      # Note: Terraform Plan/Apply are skipped because infrastructure is managed locally
      # Terraform state is not shared between local and CI/CD
      # Instead, we update ECS service directly with new image SHA
      # Update ECS task definition with new image SHA and redeploy service
      - name: Update ECS Task Definition with SHA Tag
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: |
          echo "Skipping Terraform apply - infrastructure already exists"
          echo "Updating ECS task definition with new image SHA: ${{ needs.build-and-push.outputs.sha }}"
          
          # Install jq for JSON processing
          sudo apt-get update && sudo apt-get install -y jq
          
          # Get current task definition
          CLUSTER="aimapp-cluster"
          SERVICE="aimapp-service"
          ECR_REPO="147923156682.dkr.ecr.eu-west-2.amazonaws.com/aimapp-repo"
          NEW_IMAGE="$ECR_REPO:${{ needs.build-and-push.outputs.sha }}"
          
          # Get current task definition ARN
          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster $CLUSTER \
            --services $SERVICE \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].taskDefinition' \
            --output text)
          
          echo "Current task definition: $TASK_DEF_ARN"
          
          # Get task definition JSON
          aws ecs describe-task-definition \
            --task-definition $TASK_DEF_ARN \
            --region ${{ env.AWS_REGION }} \
            --query 'taskDefinition' > /tmp/task-def.json
          
          # Update image in task definition
          jq ".containerDefinitions[0].image = \"$NEW_IMAGE\"" /tmp/task-def.json > /tmp/new-task-def.json
          
          # Remove fields that can't be specified when registering new revision
          jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' /tmp/new-task-def.json > /tmp/final-task-def.json
          
          # Register new task definition
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file:///tmp/final-task-def.json \
            --region ${{ env.AWS_REGION }} \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "New task definition: $NEW_TASK_DEF_ARN"
          
          # Update service to use new task definition
          aws ecs update-service \
            --cluster $CLUSTER \
            --service $SERVICE \
            --task-definition $NEW_TASK_DEF_ARN \
            --region ${{ env.AWS_REGION }}
          
          echo "✅ ECS service updated with image: $NEW_IMAGE"

  # Job 3: Post-Deploy Health Check
  health-check:
    name: Post-Deploy Health Check
    runs-on: ubuntu-latest
    needs: terraform-deploy
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_GITHUB_ACTIONS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get application URL
        id: url
        run: |
          # Use AWS CLI or construct URL from known domain
          # Since we know the domain from terraform.tfvars, we can construct it
          APP_URL="tm.roodyadamsapp.com"
          echo "url=$APP_URL" >> $GITHUB_OUTPUT

      - name: Wait for deployment
        run: |
          echo "Waiting 30 seconds for ECS service to stabilize..."
          sleep 30

      - name: Health Check
        id: health
        run: |
          APP_URL="${{ steps.url.outputs.url }}"
          MAX_RETRIES=10
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://${APP_URL}/status || echo "000")
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "✅ Health check passed!"
              exit 0
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "Attempt $RETRY_COUNT/$MAX_RETRIES failed (HTTP $HTTP_CODE). Retrying in 15 seconds..."
            sleep 15
          done
          
          echo "❌ Health check failed after $MAX_RETRIES attempts"
          exit 1

      - name: Job Summary
        if: always()
        run: |
          if [ "${{ steps.health.outcome }}" == "success" ]; then
            echo "## ✅ Deployment Successful" >> $GITHUB_STEP_SUMMARY
            echo "Application is healthy at: https://${{ steps.url.outputs.url }}" >> $GITHUB_STEP_SUMMARY
            echo "Image SHA: ${{ needs.build-and-push.outputs.sha }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "## ❌ Deployment Failed" >> $GITHUB_STEP_SUMMARY
            echo "Health check failed. Please check ECS service logs." >> $GITHUB_STEP_SUMMARY
            echo "Application URL: https://${{ steps.url.outputs.url }}" >> $GITHUB_STEP_SUMMARY
          fi

